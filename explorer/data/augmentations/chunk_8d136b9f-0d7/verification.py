import itertools
from collections import defaultdict

def generate_fano_plane():
    """Generate the Fano plane as 7 points and 7 lines"""
    # Points labeled 0-6
    points = list(range(7))
    
    # The 7 lines of the Fano plane (each line contains 3 points)
    # Using the standard construction
    lines = [
        [0, 1, 3],  # Line 1
        [1, 2, 4],  # Line 2
        [2, 3, 5],  # Line 3
        [3, 4, 6],  # Line 4
        [4, 5, 0],  # Line 5
        [5, 6, 1],  # Line 6
        [6, 0, 2]   # Line 7
    ]
    
    return points, lines

def get_all_triangles(points, lines):
    """Get all non-collinear triples (triangles)"""
    triangles = []
    line_sets = [set(line) for line in lines]
    
    # Check all 3-combinations of points
    for triple in itertools.combinations(points, 3):
        triple_set = set(triple)
        # A triple is a triangle if it's not contained in any line
        if not any(triple_set == line_set for line_set in line_sets):
            triangles.append(sorted(list(triple)))
    
    return triangles

def compute_anti_incidences(points, triangles):
    """Compute all (point, triangle) pairs where point is NOT in triangle"""
    anti_incidences = []
    for point in points:
        for triangle in triangles:
            if point not in triangle:
                anti_incidences.append((point, tuple(triangle)))
    
    return anti_incidences

def analyze_point_triangles(point, triangles):
    """For a given point, split triangles into those containing it and those not"""
    containing = []
    not_containing = []
    
    for triangle in triangles:
        if point in triangle:
            containing.append(triangle)
        else:
            not_containing.append(triangle)
    
    return containing, not_containing

def triangle_to_complement(triangle, all_points):
    """Map a triangle to its complement (4 points not in the triangle)"""
    return sorted([p for p in all_points if p not in triangle])

def verify_block_design(triangles, points):
    """Verify the 2-(7,4,8) block design structure"""
    # Map each triangle to its complement
    blocks = [triangle_to_complement(t, points) for t in triangles]
    
    # Verify each block has 4 points
    assert all(len(b) == 4 for b in blocks), "Not all blocks have 4 points"
    
    # Count how many blocks contain each pair of points
    pair_counts = defaultdict(int)
    for block in blocks:
        for pair in itertools.combinations(block, 2):
            pair_counts[tuple(sorted(pair))] += 1
    
    # Verify each pair appears in exactly 8 blocks
    return all(count == 8 for count in pair_counts.values())

def main():
    print("=== FANO PLANE CHAKRA ANALYSIS ===\n")
    
    # Generate Fano plane
    points, lines = generate_fano_plane()
    print(f"Fano plane has {len(points)} points: {points}")
    print(f"Fano plane has {len(lines)} lines:")
    for i, line in enumerate(lines):
        print(f"  Line {i+1}: {line}")
    
    # Get all triangles
    triangles = get_all_triangles(points, lines)
    print(f"\nTotal non-collinear triples (triangles): {len(triangles)}")
    assert len(triangles) == 28, "Should have exactly 28 triangles"
    
    # Compute anti-incidences
    anti_incidences = compute_anti_incidences(points, triangles)
    print(f"\nTotal anti-incidences (point NOT in triangle): {len(anti_incidences)}")
    assert len(anti_incidences) == 112, "Should have exactly 112 anti-incidences"
    
    # Demonstrate the 12/16 split for a chosen point (Nada Brahman)
    chosen_point = 0  # Let point 0 be "Nada Brahman"
    containing, not_containing = analyze_point_triangles(chosen_point, triangles)
    
    print(f"\n=== ANALYSIS FOR POINT {chosen_point} AS 'NADA BRAHMAN' ===")
    print(f"Triangles containing point {chosen_point}: {len(containing)}")
    print(f"Triangles NOT containing point {chosen_point}: {len(not_containing)}")
    
    # The 12 triangles containing the chosen point can represent Sa and other swaras
    print(f"\nThe {len(containing)} triangles through point {chosen_point}:")
    for i, t in enumerate(containing):
        print(f"  Triangle {i+1}: {t}")
    
    print(f"\nAnti-incidences for point {chosen_point}: {len(not_containing)}")
    print(f"These {len(not_containing)} represent the chakras generated by this point")
    
    # Verify the 2-(7,4,8) block design
    is_valid_design = verify_block_design(triangles, points)
    print(f"\n=== BLOCK DESIGN VERIFICATION ===")
    print(f"2-(7,4,8) block design structure valid: {is_valid_design}")
    
    # Show complement mapping for first few triangles
    print("\nExample triangle-to-complement mappings:")
    for i, triangle in enumerate(triangles[:5]):
        complement = triangle_to_complement(triangle, points)
        print(f"  Triangle {triangle} -> Complement {complement}")
    
    # Verify the arithmetic
    print(f"\n=== ARITHMETIC VERIFICATION ===")
    print(f"Points × Triangles per point = {len(points)} × {len(not_containing)} = {len(points) * len(not_containing)}")
    print(f"Total anti-incidences = {len(anti_incidences)}")
    print(f"Verification: {len(points) * len(not_containing) == len(anti_incidences)}")

if __name__ == "__main__":
    main()